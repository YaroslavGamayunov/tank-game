# Об устройстве графического интерфейса

Графический интерфейс связан с логикой игры двумя уровнями абстракции - графическими обьектами, которые "рисуют" наши
 юниты и их рендерерами, которые абстрагируют вызовы функций графической библиотеки. Для это были использованы следующие 
 паттерны проектирования

# **1) Мост** 

В нашем проекте мост разделяет иерархии классов реализаций *IVisualObject*  и *IVisualObjectRenderer*. Реализации 
*IVisualObject* агрегируют *IVisualObjectRenderer* с помощью объекта *renderer*. Достаточно выбрать версию абстракции и 
реализации и связать их между собой, что мост и помогает сделать. Сделано это с целью абстракции логики графического 
интерфейса от графической системы. На данной стадии мы разрабатывали иерархию под Swing. То есть, сконструировав
 наследник *IVisualObject* с правильно реализованым рендером, мы можем запустить игру на другой граф. библиотеке,
  например OpenGL или OpenGL ES, с помощью которого можно будет играть, на мобильных устройствах

# **2) Компоновщик**

В классе *VisualObjectCompositor*, реализующем интерфейс *IVisualObject*, дети расположены в виде дерева. Дети могут 
быть, как и "листьями", так и иметь детей, поэтому мы заведомо не знаем тип ребенка.  Составной элемент дерева имеет 
функции, аналогичные функциям "листа", но передает вызовы этих функций по рекурсии. Более того, положения спрайтов тоже
 рассчитываются изсходя из положений рожительских обьектов, что позволяет создать сложный обьект, который будет нетрудно 
 перемещать

# **3) Декоратор**

Составной элемент дерева передает вызов функции в листья с помощью метода *callAllChilds*, которым продекорированы
 функции *start*, *update* и *destroy*. Декоратор реализован в виде функции принимающей функцию и вызывающей ее, 
 так как это более целесообразно в kotlin'e

# **4) Адаптер**

Чтобы адаптировать Swing, мы пишем своеобразный Adapter его классов под нашу иерархию рендереров. Например, 
*SwingSpriteRenderer* реализует *IVisualObjectRenderer*, переадрисуя отрисовку картинки в Swing

# **5) Абстрактная фабрика**

В качестве интерфейса нашей фабрики выступает класс *IRendererFactory*, который реализует на данной 
стадии разработки лишь класс *SwingRendererFactory*, который предназначен для конструирования обьектов для работы 
с графической подсистемой - то есть только фабрика должна знать, какие классы рендереров ответсвенны за отрисовку 
различных элементов. Это значительно снижает количество зависимостей

# **6) Цепочка обязанностей**

Поскольку игроки могут быть нечестными или может возникнуть ошибка, сервер должен проверять входящие пакеты на 
корректность, и для этого мы решили использовать цепочку обязанностей. Для этой цели мы разработали классы 
*ServerPacketValidatorChain* и *ServerPacketValidatorChainLink*. Цепочка состоит из последовательных проверок свойств
присланного на сервер пакета, и если проверка не прошла, следующее свойство не проверяется, выбрасывается искллючение.
 Сначала проверяется, что тип пакета соответствует содержимому, после чего проверяется,
 что действия игрока корректные. Планируется еще проверять, что пакет отправляется тем же самым игроком,
  который зашел на сервер.

# **7) Наблюдатель**

Наблюдатель - это самый часто используемый паттерн в части, отвечающей за сервер. Поскольку сервер может иметь несколько
подключенных игроков, ему необходимо постоянно синхронизировать состояние игры между всеми присоединившимися пользователями, 
и когда от одного игрока приходит проект с пометкой shouldBeShared, сервер оповещает остальных о том, что произошло действие.
Таким образом, игроки подписываются на обновления сервера, подключаясь к нему 

# **8) Команда**

Поскольку наша игра - это пошаговая стратегия, каждый ход представляет собой набор команд вроде
 'Доехать из точки A в точку B', 'Повернуть башню', 'Выстрелить' и так далее, удобно было оформить это в интерфейс
  *IGameAction*. Таким образом, легко пересылать набор действий игрока на сервер, а также удобно визуализировать набор событий. 
